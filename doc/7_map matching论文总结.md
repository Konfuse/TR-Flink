# 路网匹配论文总结
路网匹配将GPS轨迹点映射到实际的路网上。大多数现存的路网匹配算法使用各种权值函数从候选点中决定正确的位置。权值可以由很多信息来决定，比如GPS点到候选边的距离，当前的前进方向，道路的拓扑结构，物体的瞬时速度以及前后点之间的关联等。

权值算法主要分为两类:增量算法和全局算法。增量算法每次读入最新的轨迹数据，只根据这个新数据和之前的已知数据来确定新数据所对应的的匹配的位置。增量算法更多的应用于实时应用场景。但是当采样率比较低的时候，匹配准确率下降的非常显著，也难以应付城市路网的复杂环境。

全局算法则是将一整段轨迹数据进行整体分析，所以可以对轨迹中的每一个点，利用该点前后的数据信息判断该点的最佳匹配位置。离线路网匹配使用全局算法能够获得更加准确的匹配的结果。如果一条轨迹的数据量太大，也有将轨迹数据进行切分的方式来达到提高匹配效率的问题。

----

## 1. Hidden Markov Map Matching Through Noise and Sparseness[GIS 2009]
首选浅谈一下隐马尔科夫模型HMM（Hidden Markov）。隐马尔科夫模型HMM是一个描述一个含有未知参数的马尔可夫过程统计模型。隐式马尔科夫模型五要素: 2个状态集合和3个概率矩阵。

>隐含状态S：马尔可夫模型中实际所隐含的状态，通常无法通过直接观测得到。这些状态之间满足马尔可夫性质
> 
>可观测状态O：可以通过直接观测而得到的状态，在隐马尔科夫模型中与隐含状态相关联。
>
>状态转移概率矩阵A：描述隐马尔可夫模型中各个状态之间的转移概率
>
>观测状态概率矩阵B：表示在t 时刻隐含状态是Sj 条件下，其可观测状态为Ok 的概率。
>
>初始状态概率矩阵π：表示隐含状态在初始时刻t=1 的概率矩阵

为了将隐马尔科夫模型HMM应用到路网匹配中，这里将每一个轨迹点作为一个可观测状态，将轨迹点组成的序列作为观测序列。而轨迹点的候选道路投影作为HMM求解的对象--隐含状态。由这些候选点（路段）构成的序列就是隐藏序列。这里需要决定的就是其转移概率和观测概率如何确定。隐马尔科夫模型HMM是路网匹配工作中非常流行的全局算法。

如何根据每个轨迹中的GPS点确定其由之前状态达到当前状态的具有最大的概率的候选点？一般是参考维特比算法（Viterbi）。其算法的主要思路是：
1. 初始化第一个观测点的所有可能状态概率。
2. 从前往后遍历每一个状态，对于每一个状态，用以下方法计算当前观测点的所有可能状态的概率：a)遍历当前观测可能对应的所有状态；b)对每个状态，遍历所有上一状态，通过公式 P(当前状态) = P(上一状态) * P(上一状态转移到当前状态) * P(当前状态观测) 来计算当前状态的概率。
3. 当所有观测点都遍历完之后，查找概率值最大的那个状态，然后查找这个概率值对应的上一状态，就这样一路往回找，所找到的序列（倒序的）就是最大概率的隐藏序列。

观测代价指代当前状态出现的代价。对应到路网匹配问题中，如何确定每个GPS点的观测代价呢？在这里一般的做法是将GPS点与其候选路段对应，一般而言，GPS定位的精度（每个点相对于路段的距离）大致满足正态分布，因此利用正态分布中的概率模型，可当做其观测概率。更多情况下，其观测代价可以由以下几个代价因素的进行加权平均：GPS点到路段的距离；GPS点前进方向和路段的方向差；GPS 点的速度与道路限速值的差异（低于限速值代价为 0，超过限速值就累加插值）。当然还有其他可以列入考虑的因素，根据不同的情况或不同的算法设计，可以采取不同的策略。

那么转移概率如何确定呢？转移代价指从上一个点到这一个点的前进过程中，从上一个点对应的某个路段到这个点对应的某个路段的代价。最一般的情况下，可以比较前一个点到当前点的真实路径距离和其两点之间距离的差值（比值）。如果值越小说明匹配的越正确。当然可以在之上考虑其他的因素，通过加权平均的方式协调各个因素对最终匹配结果的影响大小。

利用Viterbi算法，其步骤流程如下：
1. 对所有点序列进行遍历；
2. 对当前遍历到的点，进行周边抓路，将抓到的路标记为候选路段；
3. 如果不是第一个点，则将上一个点的所有保留下来的候选路段进行一定距离的扩散，获得范围内每两条路段之间的最短路径，仅保留起点是上一个点的备选路段且终点这个点的备选路段的路径；
4. 计算代价，计算方法为：上一个点的候选路段代价 + 到这个点对应候选路段的转换代价 + 这个点的观测代价；
5. 搜索到最后一个点的时候，找到代价最小的候选路段，然后依次往前追溯，找到计算出这个最小代价时经过的所有节点（包括转换路径上的路段）。

**在这篇论文中，作者通过经验和一定的数学推导最后得到的观测概率矩阵是$\mu$ = 0 和 $\sigma$ = 4.07的正态分布。$\sigma$使用绝对中位差进行鲁棒估计。状态转移矩阵是用指数函数来拟合前后两个相邻GPS观测点的距离与两个候选点距离之差的绝对值。在初始时刻使用观测概率矩阵。**

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/HMM_observation.png)

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/HMM_transition.png)

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/HMM_beta.png)

**在这篇论文中提出，可以使用滑动窗口的模式来处理实时数据的路网匹配（批处理模式）**

---

## 2. Map-matching for low-sampling-rate GPS trajectories[GIS 2009]
ST-Matching 算法是一种处理低频采样数据的路网匹配算法。该算法是一种全局算法，能综合几何信息（GPS点与道路的距离）、道路拓扑信息（最短路径）、道路属性信息（每条道路的限速），具有精度高，稳定性好等优点。

作者基于的观测事实是：（1）真实的路径一般都是直的（2）真实的路径会遵循道路的速度限制。本文路网匹配的主要步骤是：先根据路网索引，取得轨迹点附近的候选路段（点）（网格索引）。（2）根据轨迹的前后关系，对候选路段进行空间分析和时间分析构建一张图，图的节点是轨迹点的匹配候选点，图的边是相邻候选点之间的最短路径，图中的边和点都赋予一定的权重。（3）在得到的图中，找到一条评分最高的轨迹。

空间分析：观测概率N：GPS坐标点p和投影点c之间的距离，计算该点与投影点相匹配的概率。作者使用的是$\mu$ = 0 和 $\sigma$ = 20正态分布。然而只考虑观测概率就忽略了GPS点的时空语义。因此作者还定义了转移概率V，其意义是GPS前后点之间的距离和其投影点之间的最短距离的比例。最终通过两个之积得到概率公式。

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/ST_matching_observation_probability.png)

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/ST_matching_transmission_probability.png)

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/ST_matching_function_probability.png)

时间分析：计算候选点之间的可能的速度与路径允许的速度作比较，判断其是在高速路上还是普通的路径上。
![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/temporal_analysis_function.png)

最终得到的概率权重，用类似Viterbi算法，在全局找到一条评分最高的路径（初始概率设置为每个点的观测概率）。当一条轨迹太长时，可以使用滑动窗口的方式，对部分候选图进行匹配。

---

## 3. DeepMM Deep Learning Based Map Matching with Data Augmentation \[SIGSPATIALGIS 2019]

在这篇文章中，作者的主要思想是结合已有的深度学习方法，充分利用历史轨迹数据的运动规律信息，来对轨迹的数据进行路网匹配，并减弱轨迹中噪声的影响。本篇文章中，通过embedding技术来表示地点和路段是为了减少敏感噪音的影响，而使用注意力增强的seq2seq模型是为了学习历史的轨迹数据特征。

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/deepMM_framework.png)

这个框架的左半部分是对轨迹数据量进行拓展的方法，右半部分是深度学习模型。通过训练的模型来对新来的轨迹进行预测，最后通过路网匹配算法来得到匹配的路网轨迹。

模型中的输入数据是基于线段的轨迹。首先将整张地图分成100*100的正方形区域，将每个区域的ID转成一个one-hot向量。将输入的序列转成向量来进行相应的预测和训练。

---

## 4. Effective map-matching on the most simplified road network[SIGSPATIAL 2012]

这篇文章提出了一种Passby的路网匹配算法。主要针对问题是：由于路网数据占用很大的空间，如何在简化了路网信息的情况下进行路网匹配。这篇文章将路网信息中的每条路（可能包含多个路段）简化为{id，start，end}。在简化的路网信息会使得路网中的很多特征发生改变。如下图所示，实际道路变弄成简化道路后失去了曲线特征，因此处于$p_i$的点有更大概率匹配到另一条路上。


![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/simplified_road_example.png)

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/Passby.png)

作者基于主要发现是：一辆车的行驶轨迹是否能够匹配到一个路段上，可以通过其是否通过了这段路的路口来判断。因此，如果轨迹中的点$p_{i-1}$和$p_{i}$（当前查询点是$p_{i}$）匹配的点的路径通过一段路的起点e.start，并且其后的点$p_{j-1}$和$p_{j}$通过了这一段路的e.end，此时可以将{$p_{i}$,...,$p_{j}$}匹配到该路段上。如果其后的点不满足情况，就将$p_{i}$匹配给概率最大的一段路中。

如何判断两个点的路径是否通过一个路口呢？在下图中，作者标出了四个变量，四个变量的加权和（大于一个阈值）可以作为其是否通过路口的指标。一般而言更小的距离（$d_t和d_p$）和更小的角度（$\theta_t和\theta_i$）更好。

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/passing_by.png)

对于其后的点不满足通过路段的末点的情况，首先根据其欧式范围(r)和拓扑范围(r+|$e_1$|)来将相应范围内的路段添加到候选路段中。拓扑范围的确定依据车辆先前行驶过的节点，将一定范围内的路段取做候选路段。（有待进一步探究）。

---

## 5. Fast Viterbi map matching with tunable weight functions. SIGSPATIAL \[GIS 2012]:

这篇论文作者首先总结了当时所有的map-matching算法，分析了算法的特点。

这篇论文的方法基于前面提到的HMM算法，综合了当时存在的路网匹配算法，选择了两个最好的权重，并对路网匹配算法做了很多优化措施。

作者首先给出HMM公式：
![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/Fast_viterbi_HMM.png)

这里$\beta$和$\sigma$都是根据数特征据得出的公式，$l_i$是两个GPS点对应的匹配点之间的真实最短距离，$l_{i,0}$是两个GPS点之间的直接距离。如果两个距离之间大小越相近，就说明越是可能的匹配。可以将如上公式取log得到如下的公式。

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/Fast_viterbi_HMM2.png)

上面公式中，$\alpha = 2 \sigma^2/\beta$。作者比较了HMM和lou09中使用的方法，改进的lou09中使用的公式中将HMM中的$l_i - l_{i,0}$替换成了$- l_i / l_{i,0}$（原始是整个转移概率为$l_{i,0}/l_i$）。作者对方法进行了比较，发现lou09在采样率较高的情况下效果较好，HMM在采样率较低的时候效果较好。于是自己设计了一个计算公式：

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/Fast_viterbi_author.png)

其中，$t_i$是$z_i$和$z_{i-1}$之间的采样间隔，$l_i$直接取的是最短距离。

作者之后改进了算法，维特比映射匹配的瓶颈是每个连续匹配候选对的最短路径计算。在Dijkstra算法中添加了sample_interval * 50m/s的搜索范围限制。为了减少候选集的大小，将搜索半径限制在30米以内，因为对于训练数据集来说，样本与其匹配的道路之间的最大距离约为25米。

---

## 6. Quick map matching using multi-core CPUs \[SIGSPATIALGIS 2012]

本文考虑到现有的方法如HMM，已经可以取得较高的准确率。因此本文重点关注方向是减少路网匹配的时间。这篇文章的方法充分利用了多核cpu的多线程，多线程可以应用到索引的构建、搜索和路网的匹配上。本文对上面的HMM方法进行了一点改进，将路段的速度信息进行了考虑，避免轨迹匹配到主路旁的辅路上。

索引的构建：本文首先将地图划分成网格，每个网格记录在内的或与其相交的路段。因此现将所有轨迹段分成N组，每组可以在多线程中进行索引的构建。

索引的搜索：对于一个查询点，首先取得该点所在的区域。之后得到该区域附近的8个相邻区域，如果这个区域与查询点之间的距离小于50m，就将其纳入到候选区域中，再对所有候选区域中的所有路段再判断其与查询点的距离是不是大于50m，将这些不符合条件的路段排除。最终得到所有的候选路段。

路网匹配：本文对所有轨迹按照进行分组（并行度个数），对每个组进行并行路网匹配。路网匹配的算法使用的是HMM。

该方法还考虑了对主路和辅路的匹配问题，辅路上的车辆车速比主路上的慢，因此在转移概率上加上了速度限制。

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/HMM_speed_limitation.png)

---

## 7. An efficient algorithm for mapping vehicle trajectories onto road networks \[SIGSPATIALGIS 2012]

这篇论文的主要思路是：（1）索引的构建：首先根据路网中的所有节点（mini-vertices）构建网格索引。

（2）候选路段集的获取：对于一个轨迹点，首先搜索与查询点$q_i$最近的50个路网节点（mini-vertices），得到查询点的候选路网节点集，判断路网节点在哪个路段上，根据这些候选轨迹段得到候选路段集S（目标是得到$q_i$的精确候选路段集$C_i$，$C_i \in S$ ）。

由于两个相邻的点更可能被匹配到同一条路段上。假若已经得到了前一个点的确候选路段集$C_{i-1}$，首先将同时出现在S中和$C_{i-1}$中的边加入到集合S'中，其次找到S中的某些边的起点等于$C_{i-1}$中某些边的终点的边，将这些边也放到集合S'中。

再对集合S'进行进一步细化，首先剔除与轨迹点p之间距离大于18m的路段。其次对每个路段（有很多小路段组成）连接其首尾点得到线段L，计算线段L与e={$q_{i-1}$,$q_i$}之间所成的角度$\alpha$，如果$\alpha$大于90度，将该路段剔除出S'。如果S'不为空，将$C_i$设置为S'。

如果S'为空，重新考虑集合S，对集合中每个路段e，计算如下所示分数。其中下式中的各种参数是人为指定的，作者已在论文中给出。其意图是，路段与查询点越接近，L与e={$q_{i-1}$,$q_i$}所成的角度越小，就有更大概率进行匹配。得到所有分区中最大的score，剔除分数小于0.8*score的边，最后得到$C_i$。

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/map_matching_scores.png)

（3）假若$P_i$是点$q_i$的候选轨迹段上的匹配点集，首先构造两个虚拟点s和t，分别指向所有的$P_1$（起始点的匹配点）和$P_m$（某点的匹配点），设置所有的权重为0，计算从s到t的最短路径，需要满足如下两个条件（1）每个点集中至少有一个点要出现在路径中（2）必须依次通过所有的点集。经过这些步骤之后，得到的候选点$p_i'$所在的边$e_i$作为最佳匹配。

论文中的批处理思想还是对不同轨迹段在不同线程中进行匹配。

---
## 8. Fast map matching, an algorithm integrating hidden Markov model with precomputation \[IJGIS 2018]
![](pic/FMM.png)
算法包含两个部分：预计算部分和隐式马尔科夫过程部分。
1. 预计算部分、
  
   最短路径的计算：论文中的方法是遍历图中的每一个点，将该点到其他点小于一个阈值$\delta$的最短路径信息(SP)存储到一张表Upper Bounded Origin Destination Table(UBODT)中。其每一条信息的存储方式如下：$R(n_o, n_d) = (n_o, n_d, next_n, next_e, prev_n, dist)$。在这里$n_o, n_d$指代起始点和末点的id号，$next_n, next_e, prev_n$指代在这个路径中(way)起始点的下一个的点的id、起始点指向的边的id和路径中末点之前点的id。SP信息由Dijkstra算法生成。最终UBODT存储成hash table形式，其对应关系是：$h = (n_o*M + n_d) mod H$。因此任意两点之间的最短径可以通过之前存储的信息以递归的方式获得。如果没有找到最短路径，此时才调用Dijkstra算法进行查找(对于长度大于阈值的情况，作者列出了4种情况去计算)。

2. 隐式马尔科夫过程

    (1) 候选投影点(候选路段)的查找：文中使用的是在R-tree中查找一个GPS点的r范围内的k最近邻(KNN)候选。每条信息存储成$C = (p,e,dist,\lambda)$，分别代表投影点，候选边，GPS点到线距离，投影点到起始点的距离。在实际中，作者搜索时首先构建一个以GPS点为中心，以2r为边长的正方形，找到所有与正方形相交的路段（或内部），再将点投影到路段上，筛除GPS点到线的距离大于r的路段，对剩下的候选按距离进行排序。

    (2) 最佳路径的选取：投影点之间的路径可能存在的4种情况如下图所示。这里考虑到的是行驶方向的问题，这样可以使得真实GPS点的距离和最短路径距离的比值更加准确。
   ![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/FMM_OPI.png)
   ![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/FMM_OPI_FORMULA.png)

   (3) GPS点可能投影的位置有如下三种情况可能出现问题。第一种情况是GPS之间距离大于路径距离，其转移概率大于1。第二，三种情况是两个点投影到同一个点使得分母为0。
   ![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/FMM_GPS_candidate.png)

   文章中转移概率如下，使得第一种情况小于1，第二三种情况等于0。
   ![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/FMM_TRANSITION.png)

   论文中的观测概率依旧如HMM中的标准正太分布一样。最终可以通过viterbi算法得到最优的匹配路径OPI。

   (4) 在找到最优的匹配路径后OPI，作者希望找到一整条完整的路径CPI（通过OPI）。作者整个查询的过程中只在这里才使用最短路径的计算。前面的最短路径都是通过预计算得到的，这样就节省了时间。

   (5) 惩罚机制：如下图所示，GPS点$p_n$匹配后可能在计算最短距离时经历了一个反向运动。因此文中在投影点之间的最短距离计算之上添加了一个惩罚距离。pf为惩罚因子。在施加惩罚后，包含反向运动的路径很可能被赋以较低的转移概率，并在OPI步骤中被消除。
   ![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/FMM_PENALTY.png)
   ![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/FMM_PENALTY_FORMULA.png)