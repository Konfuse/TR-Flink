# 路网匹配研究文献

## 一、绪论

伴随着互联网的快速发展，现代社会逐步进入万物互联的大数据时代，社会生活中人类无时无刻不在创造和使用着大数据。随着定位技术和无线通信技术的发展，可移动设备的数量呈爆炸式的增长，越来越多的可移动对象的轨迹数据被收集起来。全球定位系统（GPS）传感器已经广泛部署在车辆和智能手机上。很多智能手机应用会请求提取用户的位置信息来对用户进行具有地域特色的信息推荐。而每时每刻产生的轨迹数据蕴含着与移动对象相关的丰富信息，在城市规划和公共安全预测等应用场合具有重要的价值。例如滴滴出行应用每隔几秒便会上传司机的位置信息，通过收集的信息可以对拥堵情况和出行需求进行判断，从而提供相应的路径规划服务来提高司机的效益。

移动对象运动的轨迹是连续的，但轨迹数据的表示却是离散的，轨迹数据由一系列的轨迹点数据组成，可移动设备的GPS芯片会每个固定的时间间隔采集一次GPS定位信息，主要包括GPS经纬度坐标，精度，速度和在各个方向的加速度等信息，信息对用户运动状态特征的描述十分具体，所以可以对其挖掘的信息非常丰富，但是对于轨迹的分析具有以下三个主要的问题：

1. 不均匀的时空采样：当用户设备的连接出现异常或者数据传输产生延迟，会直接导致轨迹点采样的不均匀，这是一个不规则但应该很少出现的一个因素。
2. 较大的定位偏差：在实际定位过程中，GPS点信息采集的时候会受到GPS卫星信号强弱或者附近信号干扰的影响，再加上GPS定位系统本身的偏差，轨迹信息的定位结果飘逸在十米到几十米不等，这样收集到的点都是具有随机漂移的点。
3. 不具有元信息数据：轨迹数据本身并不包含轨迹的起始和终结点的信息。

由于GPS定位采样的位置信息具有测量误差并且道路上连续运动的车辆的轨迹由一系列离散点来代替，车辆的运动路径变得难以进行判断。为了推断车辆的运行路径，一般对离散的轨迹点进行路网匹配操作，将车辆的一系列轨迹点坐标定位到道路地图上。路网匹配是基于“轨迹始终分布在道路上”的假设，将存在定位偏差的GPS轨迹数据点匹配到最有可能的地图路网中的路段上。

目前随着可移动设备爆炸式的增长，轨迹数据的规模变得越来越大，过去使用单一计算节点的轨迹处理方法变得不再实用，很多研究便由此提出了分布式或者并行的解决方案以实现大规模轨迹数据的处理。这些研究的问题定义使用历史的轨迹数据，同时采取离线批处理的方式。但是考虑到在目前这个网络互联的时代，人们对查询的交互性性能要求越来越强烈，在海量数据集上实时地对轨迹数据进行处理才是当下的热点。

## 二、相关工作

现有的大多数路网匹配算法使用各种权值函数从候选点中决定正确的位置。权值可以由很多信息来决定，比如GPS点到候选边的距离，当前的前进方向，道路的拓扑结构，物体的瞬时速度以及前后点之间的关联等。

全局算法则是将一整段轨迹数据进行整体分析，对轨迹中的每一个点，利用该点前后的数据信息判断该点在道路中的最佳匹配位置，进而找出权重最大的匹配路径。大多数全局算法采用隐马尔可夫模型(HMM)，并采用Viterbi动态规划算法。离线路网匹配使用全局算法能够获得更加准确的匹配的结果。[4]是一种处理低频采样数据的路网全局匹配算法，采用了隐式马尔科夫模型。该算法的利用高斯分布来模拟观测概率，而状态转移概率则是综合了速率信息，观测点和隐藏实际点的信息计算出来。[2]与[4]类似，[2]也采用了隐式马尔科夫模型，但[2]没有考虑速率信息，并且观测概率的定义更符合实际。在这篇论文中，作者通过经验和一定的数学推导得到的观测概率是$\mu$ = 0 和 $\sigma$ = 4.07的正态分布。而转移概率则用指数函数来拟合前后两个相邻GPS观测点的距离与两个候选点距离之差的绝对值。[5]考虑了路段的速度信息，避免轨迹匹配到主路旁的辅路上。算法充分利用多线程思想应用到索引的构建、搜索和路网的匹配上，来提高路网匹配的效率。[6]相比之前的算法不是利用路段来构建索引，而是利用所有路段端点来构建空间索引。该算法考虑了GPS前后点和路网拓扑结构之间的联系，对不符合条件的路段进行快速过滤，以达到提高搜索效率的目的。本文所采用的算法基础是FMM[1], 该算法将将隐马尔可夫模型与预计算相结合的来提高路网匹配的效率。预计算阶段从道路网络中构建了一个起点-目的地表，并将一定长度内的所有最短路径对存储在表中，提高了路网匹配算法在计算最短路径时的效率问题。从以上的算法可以看出，这些算法大都利用轨迹和路网拓扑结构之间的经验模型提高路网匹配准确度，并针对路网匹配的计算瓶颈过程采用并行计算或预计算的方式来提高匹配的速度。

权值算法主要分为两类:增量算法和全局算法。增量算法每次读入最新的轨迹数据，只根据这个新数据和之前保留的已知数据信息来确定新数据所对应的所处道路的最佳匹配位置。增量算法更多的应用于实时应用场景中。当采样率比较低的时候，算法匹配准确率下降的非常显著，也难以应付城市路网的复杂环境。[3]利用汇聚点的信息处理实时路网匹配，假设在当前时间的所有点在马尔科夫链中都汇聚于上一个时间的某一个点，就将上一个时间的那个点记为汇聚点。每得到一个汇聚点，将该汇聚点和前一个汇聚点之间的具有最大转移概率的路径输出。若在不断向后处理的过程中没有汇聚点出现，当时间超过一定时间时，就直接将具有最大转移概率的路径进行输出。该算法对采样率和GPS定位的精度有很高的需求，当采样率较低或某些点定位精度较低时，算法的实时性和准确率会受到较大的影响。

[7]结合已有的深度学习方法，充分利用历史轨迹数据的运动规律信息，来对存在候选匹配路段的区域进行预测，再对轨迹的数据利用原始的路网匹配算法进行匹配。[7]并没有对原有路网匹配计算的效率进行提高，而是利用embedding技术来表示地点和路段，并使用添加注意力增强机制的seq2seq模型是学习历史的轨迹数据特征，减少了敏感噪音的影响。

考虑到现轨迹数据量愈发庞大并且路网匹配在单机上执行的效率较低的问题，有部分文献采用分布式计算的思想来提高大规模轨迹数据匹配的问题。[8]利用希尔伯特构造曲线的构造方式，对整个路网区域按照设置的并行度进行分区，将相邻的单元格进行聚集，使得每片区域具有大致均等数量的路网路段，保证了负载的均衡。再对每个分区中的空间数据构建本地R-tree索引，便于每个分区中的路段的查找。对于一个查询点，找到其对应的分区，再查找其候选的匹配路段。最后对每条轨迹的每个GPS点的所有候选的路段结果集进行汇总，再利用现有的路网匹配算法对轨迹进行匹配。[9]首先根据采样的轨迹数据对空间进行分区，并构建全局四叉树索引结构。其次将所有路网数据和对应轨迹数据利用四叉树索引找到相对应的分区。在相应的分区中，查找每个轨迹段的候选匹配路段集。最后将所有结果进行收集，利用路网匹配算法对轨迹进行匹配。从以上的文献中可以看出现有的分布式路网匹配算法主要是通过空间划分的方式提高候选路段搜索的效率，来解决大规模轨迹数据匹配的问题。

## 3.研究内容

轨迹数据在很多地方都有被应用，例如滴滴出行手机软件会利用轨迹数据为司机的行车路线进行规划、城市相关部门可以利用轨迹数据分析城市建设并进行相应的规划、动物的出行规律也可以通过分析其轨迹来进行一定的预测。下面首先给出在二维空间中轨迹数据的定义。

轨迹数据T定义：$T={p_1,p_2,p_3,…,p_n}$，其中$p_i=\{x_i,y_i,t_i\}$是轨迹在$t_i$时刻处于2维空间中的坐标。

道路网路使用有向图G(V,E)表示，V是路网中的节点集，E是路网中的路段集。V中的每个节点代表道路网络中的交叉口或道路拐点。E中的每条边e是一个有向线段，其ID号用eid进行指明，其起始点和终止点的ID号分别用sid和tid来表示。每个路段几何形状是用geom表示的长度为L的折线。因此每个路段可以表示为$e = (eid, sid, tid, geom, L)$。

地图匹配是将车辆的一系列GPS坐标定位到道路地图上，进而确定车辆行驶路径的过程。 对于轨迹$T_i$, 经过路网匹配后输出的结果为一系列处于路网上的位置序列$S_i = \{p_1',p_2',p_3',…,p_n'\}$。

现有的离线路网匹配算法的基本过程如下：

1. 对轨迹数据$T=\{p_1,p_2,p_3,…,p_n\}$，找出每一个GPS采样点$p_i$在半径为r的范围内的所有处在路段上的候选点集合$\{p_{i_1},p_{i_2},p_{i_3},...,p_{i_m}\}$。
2. 对每一个候选点计算其相应的权重。
3. 输出具有最大权重的匹配序列。

## 4. 框架方法

FMM算法的输入是轨迹数据集TR和该轨迹数据集所对应的路网G。算法包含两个部分：预计算部分和隐式马尔科夫过程部分。预计算过程提前计算了部分最短路径的信息，通过空间换时间的方式解决了路网匹配过程中由计算最短路径导致的瓶颈问题。而在隐式马尔科夫过程中，算法加入了路网的结构和轨迹之间的经验信息，提高了路网匹配的精度和效率。

### 4.1 预计算过程

在预计算过程中，FMM会遍历图中的每一个点，将该点到其他点小于一个阈值$\delta$的最短路径信息(SP)存储到一张表Upper Bounded Origin Destination Table(UBODT)中。预计算过程采用了以空间换时间的方式，提前计算部分最短路径信息，在路网匹配计算转移概率的时候直接通过查表找到相关信息，解决了路网匹配过程中因计算最短路径而导致的瓶颈问题。其每一条信息的存储方式如下：

$R(n_o, n_d) = (n_o, n_d, next_n, next_e, prev_n, dist)$。

在这里$n_o, n_d$指代起始点和末点的id号，$next_n, next_e, prev_n$指代在这个路径中(way)起始点的下一个的点的id、起始点指向的边的id和路径中末点之前点的id。最短路径的信息由Dijkstra算法生成。最终UBODT存储成以$(n_o, n_d)$为key的hash table形式。算法预先设置哈希表的桶个数H和乘数M。对于$R(n_o, n_d)$，算法利用$h = (n_o*M + n_d) mod H$将相应的信息加入到对用的桶中。其中$0 \leq h \leq H$。

因此任意两点之间的最短径长度可以通过之前存储的信息以递归的方式获得。

$Path(n_o, n_d) = <R(n_o, n_d).next_e, R((n_o, n_d).next_n, n_d ).next_e,...>$

如果没有找到最短路径长度，即两点之间可能不存在最短路径或者最短路径的长度大于$\delta$，此时需要采取其他策略：1. 重新计算两点之间的最短路径。2. 将两点之间的最短路径用一个较大的值来代替。

### 4.2 路网匹配过程

路网匹配的过程中包含如下几个步骤：1. 在根据路网构建的索引中搜索每个GPS点的候选的匹配路段，并计算相应的投影点。2. 

#### 4.2.1 候选投影点(候选路段)的查找

对于路网G，算法首先对路网中的所有路段构建R-tree索引。对于每一条轨迹，算法在R-tree中查找所有所有GPS点的r范围内的k最近邻(KNN)候选。每一条候选信息存储成$C = (p,e,dist,\lambda)$，分别代表投影点位置，候选边，GPS点到路段距离，投影点到起始点的相对于路段的距离。

在实际的搜索过程中，算法在搜索所有的候选路段时搜首先构建一个以GPS点为中心，以2r为边长的正方形，找到所有与正方形相交的路段或在正方形内部的路段，再将点投影到路段上，筛除GPS点到线的距离大于r的路段，对剩下的候选点按距离进行排序。

#### 4.2.2 转移矩阵的计算

在这个阶段需要根据轨迹和路网之间的相关信息构建转移概率矩阵。FMM算法相比HMM算法[2],考虑了一些特殊的情况，提高了匹配的准确性和匹配效率。实际所用的算法采用的方案主要有：1. FMM中投影点之间的最短路径距离计算方式。2. HMM的转移概率的计算在实际情况下更好。FMM在某些情况下考虑的更全面。 

对于$p_n$和$p_{n+1}$，其投影的路段分别是$C_n$和$C_{n+1}$， 在路段上的投影点分别是$C_n.p$和$C_{n+1}.p$，$C_n.s$和$C_n.t$分别定义为按照行驶方向定义的路段的起始点和终止点，$C_n.\lambda$代表投影点与起始点之间在整个路段上的距离。投影点之间的最短路径距离计算方式主要有三种情况需要考虑：1. 若$C_n \neq C_{n+1}$， 那么其最短路径表示为$C_n.p->C_n.t->...->C_{n+1}.s->C_{n+1}.p$。2.若$C_n = C_{n+1}$ 并且 $C_n.\lambda \leq C_{n+1}.\lambda$，那么其最短路径表示为$C_n.p->C_{n+1}.p$。3. 若$C_n = C_{n+1}$ 并且 $C_n.\lambda > C_{n+1}.\lambda$，那么其最短路径表示为$C_n.p-> C_n.t->C_{n+1}.s->C_{n+1}.p$。这里考虑行驶方向的问题，使得真实GPS点的距离和最短路径距离的比值更加准确。因此其计算公式如下所示：

$$
Dist_{n,n+1}=\left\{ 
\begin{matrix}
C_{n+1}.\lambda - C_n.\lambda, if C_n = C_{n+1},C_n.\lambda \leq C_{n+1}.\lambda \\
C_n.L - C_n.\lambda + SP_{n,n+1} + C_{n+1}.\lambda,else \\
\end{matrix}
\right.
$$

考虑到GPS点$p_n$匹配后在计算最短距离时可能经历了一个反向运动。因此需要在投影点之间的最短距离之上添加了一个惩罚距离。pf为惩罚因子。在施加惩罚后，包含反向运动的路径被赋以较低的转移概率，并在OPI步骤中被消除。

![](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/FMM_OPI.png)

因此终的最短距离的计算公式如下：

$$
Dist_{n,n+1}=\left\{ 
\begin{matrix}
Dist_{n,n+1} + pf * C_n.L, if record.next_n = C_n.s\\
Dist_{n,n+1} + pf * C_{n+1}.L, if record.prev_n = C_{n+1}.t\\
Dist_{n,n+1}, else\\
\end{matrix}
\right.
$$

HMM转移概率的计算公式如下：

$tp(C_n,C_{n+1}) = \frac{1}{\beta}e^{-\frac{d_t}{\beta}}$。

其中$d_t=|Dist_{n,n+1}-||p_n-p_{n+1}||_2|$，而$\beta$是在HMM中通过公式确定的，其值为4.07米。

#### 4.2.3 观测概率的计算

观测概率采用的是是$\mu$ = 0 和 $\sigma$ = 4.07的正态分布。其计算公式如下：

$C_n.ep = \frac{1}{\sqrt{2\pi}\sigma}e^{\frac{-(C_n.dist)^2}{2\sigma^2}}$

#### 4.2.4 最优路径的获取

在计算得到每个点的转移矩阵和观测概率后，通过隐私马尔科夫模型和Viterbi算法便可以计算得到每个点最优的匹配OPI。在找到最优的匹配路径OPI后，便可以通过查UBODT表或Dijkstra算法构建一整条完整的路径CPI。

## 五、实验结果

系统实验所使用的数据集都来自于滴滴的盖亚计划。数据集涵盖了从2018年10月到2018年11月的一个月内成都和西安二环区域的滴滴快专车平台的轨迹数据及区域内道路级别的交通指数数据（Travel Time Index ,TTI）和平均行驶速度。实验采用的是数据集中的一部分，成都轨迹数据集，共包含11970条轨迹数据。轨迹数据集中的每一条记录都以（司机ID，时间戳，经度，维度）的格式存储。GPS采样点之间的时间间隔被证实是在2-4s之间。

在实验中，所使用的路网来自OpenStreetMap的开源路网数据库，路网结构如图所示。路网中一包含5973个相连接的路段和4311个节点。实验采用Windows10的操作环境，12 GB内存和Inter Core i7-4710MQ @ 2.5GHZ的单处理器。

![roadnetwork](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/roadnetwork.png)

实验的评估指标主要包括轨迹匹配的速度和匹配的效果展示，在研究中采取的预计算方法可以大大减少匹配的计算时间，又通过改善转移概率的计算方法消除了轨迹匹配在相邻路段漂移的情况。

第一个实验为了研究轨迹匹配过程的计算效率，将本实验方法与传统的隐式马尔科夫方法和efficient map matching方法进行对比，并设置UBODT生成过程中的最大探索代价为3km，实验结果如图所示：

| 方法                   | 运行时间（秒） | 速度（条/秒） |
| ---------------------- | -------------- | ------------- |
| 本研究方法             | 1060.619       | 11.286        |
| 隐式马尔科夫           | 4809.146       | 2.489         |
| efficient map matching | 6764.118       | 1.770         |

从实验结果中可以看出，方法的预计算过程大大的加快了轨迹匹配的时间，以11.286条/秒的平均速度超过隐式马尔科夫与efficient map matching方法。

第二个实验为了解决在fast map matching中产生的轨迹所匹配路段产生漂移的场景，主要将实验方法与fast map matching中的方法进行比较。实验效果如图所示：

![image-20200301132046114](https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/fmmexperiment.png)

如图中显示，红线是GPS产生的轨迹点，黑线是经过fast map matching算法匹配完成的轨迹，可以看出红色箭头所指向的点在轨迹转弯时，将轨迹点匹配到了转弯道路的对侧，显然使用红色箭头所指向的点如果匹配到绿色箭头所指的绿色点处更合适。

在后续的实验中将模型推导过程中的转移概率替换为隐式马尔科夫的计算公式，匹配效果大大的提高，可以看出是由于fast map matching的转移概率的计算较正常偏小导致的，轨迹点之间联系不密切，所以出现轨迹偏移的情况。实验效果如图所示：

<img src="https://github.com/Konfuse/TR-Flink/blob/master/doc/pic/fixfmmexperiment.png" alt="image-20200301133639856" style="zoom:50%;" />

## 六.引用

> [1] Can Yang, Gyözö Gidófalvi: Fast map matching, an algorithm integrating hidden Markov model with precomputation. International Journal of Geographical Information Science 32(3): 547-570 (2018)
>
> [2] Paul Newson, John Krumm: Hidden Markov map matching through noise and sparseness. GIS 2009: 336-343
>
> [3] Chong Yang Goh, Justin Dauwels, Nikola Mitrovic, Muhammad Tayyab Asif, Ali Oran, Patrick Jaillet: Online map-matching based on Hidden Markov model for real-time traffic sensing applications. ITSC 2012: 776-781
>
> [4] Yin Lou, Chengyang Zhang, Yu Zheng, Xing Xie, Wei Wang, Yan Huang: Map-matching for low-sampling-rate GPS trajectories. GIS 2009: 352-361
>
> [5] Renchu Song, Wei Lu, Weiwei Sun, Yan Huang, Chunan Chen: Quick map matching using multi-core CPUs. SIGSPATIAL/GIS 2012: 605-608
>
> [6] Youze Tang, Andy Diwen Zhu, Xiaokui Xiao: An efficient algorithm for mapping vehicle trajectories onto road networks. SIGSPATIAL/GIS 2012: 601-604
>
> [7] Kai Zhao, Jie Feng, Zhao Xu, Tong Xia, Lin Chen, Funing Sun, Diansheng Guo, Depeng Jin, Yong Li: DeepMM: Deep Learning Based Map Matching with Data Augmentation. SIGSPATIAL/GIS 2019: 452-455
>
> [8] Ayman Zeidan, Eemil Lagerspetz, Kai Zhao, Petteri Nurmi, Sasu Tarkoma, Huy T. Vo: GeoMatch: Efficient Large-Scale Map Matching on Apache Spark. BigData 2018: 384-391
>
> [9] Douglas Alves Peixoto, Nguyen Quoc Viet Hung, Bolong Zheng, Xiaofang Zhou:
> A framework for parallel map-matching at scale using Spark. Distributed and Parallel Databases 37(4): 697-720 (2019)